# Certificate Specification: PCC-NIUC

**Version**: 1.0  
**Date**: January 2025  
**Status**: Final Specification

## Overview

This document defines the JSON schema and verification procedures for certificates generated by the PCC-NIUC (Privacy-Preserving Computing with Non-Interactive Universal Computing) system. Each certificate provides cryptographic attestation that a computation has been evaluated against the NIUC security property and either approved, blocked, or safely rewritten.

## Certificate Schema

### Core JSON Structure

```json
{
  "checker_version": "1.0.0",
  "input_sha256": "a665a45920422f9d417e4867efdc4fb8a04a1f3fff1fa07e998e86f7f7a27ae3",
  "output_sha256": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
  "decision": "pass",
  "violations": []
}
```

### Field Definitions

#### `checker_version` (string, required)
**Format**: Semantic versioning (MAJOR.MINOR.PATCH)  
**Purpose**: Identifies the version of the NIUC checker that performed the evaluation  
**Example**: `"1.0.0"`, `"2.1.3"`  
**Validation**: Must match pattern `^\d+\.\d+\.\d+$`

#### `input_sha256` (string, required)
**Format**: 64-character lowercase hexadecimal string  
**Purpose**: SHA-256 hash of the normalized input text  
**Domain**: Applied to post-normalization input (NFKC, casefold, zero-width removal, homoglyph mapping)  
**Example**: `"a665a45920422f9d417e4867efdc4fb8a04a1f3fff1fa07e998e86f7f7a27ae3"`  
**Validation**: Must match pattern `^[a-f0-9]{64}$`

#### `output_sha256` (string, required)
**Format**: 64-character lowercase hexadecimal string  
**Purpose**: SHA-256 hash of the computation output or rewritten code  
**Domain**: 
- For `"pass"`: Hash of original approved computation result
- For `"blocked"`: Hash of empty string `""`
- For `"rewritten"`: Hash of the rewritten, sanitized code
**Example**: `"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"`  
**Validation**: Must match pattern `^[a-f0-9]{64}$`

#### `decision` (string, required)
**Format**: Enumerated value  
**Purpose**: Security decision made by the NIUC checker  
**Allowed Values**:
- `"pass"` - Input contains no NIUC violations, approved for execution
- `"blocked"` - Input contains NIUC violations, execution prevented
- `"rewritten"` - Input contained violations but was successfully sanitized

**Validation**: Must be exactly one of the three allowed values

#### `violations` (array, required)
**Format**: Array of character span arrays  
**Purpose**: Character-level positions where NIUC violations were detected  
**Structure**: `[[start, end], [start, end], ...]`  
**Semantics**:
- `start` (integer): Zero-based inclusive start position of violation in normalized input
- `end` (integer): Zero-based exclusive end position of violation in normalized input
- Spans reference the post-normalization text used for `input_sha256`
- Empty array `[]` for `"pass"` decisions
- Non-empty array for `"blocked"` and `"rewritten"` decisions

**Examples**:
```json
// No violations (pass decision)
"violations": []

// Single violation at characters 15-22
"violations": [[15, 22]]

// Multiple violations  
"violations": [[15, 22], [45, 52], [78, 85]]
```

## Hashing Domain Specification

### Input Hashing (`input_sha256`)

**Domain**: Normalized input text after complete preprocessing pipeline

**Normalization Pipeline**:
```python
def compute_input_hash(raw_input: str) -> str:
    # Step 1: Unicode NFKC normalization
    normalized = unicodedata.normalize('NFKC', raw_input)
    
    # Step 2: Case folding
    folded = normalized.casefold()
    
    # Step 3: Zero-width character removal
    cleaned = remove_zero_width_chars(folded)
    
    # Step 4: Homoglyph mapping
    mapped = apply_homoglyph_map(cleaned)
    
    # Step 5: Hash the final normalized text
    return hashlib.sha256(mapped.encode('utf-8')).hexdigest().lower()
```

**Rationale**: Hashing the normalized input ensures that certificates remain valid even when attackers use Unicode evasion techniques. The same logical input will always produce the same certificate, regardless of its original Unicode representation.

### Output Hashing (`output_sha256`)

**Domain**: Varies by decision type

#### For `"pass"` Decisions:
```python
def compute_output_hash_pass(computation_result: str) -> str:
    return hashlib.sha256(computation_result.encode('utf-8')).hexdigest().lower()
```

#### For `"blocked"` Decisions:
```python
def compute_output_hash_blocked() -> str:
    # Always hash empty string for blocked computations
    return hashlib.sha256(b'').hexdigest().lower()
    # Returns: "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"
```

#### For `"rewritten"` Decisions:
```python
def compute_output_hash_rewritten(rewritten_code: str) -> str:
    return hashlib.sha256(rewritten_code.encode('utf-8')).hexdigest().lower()
```

**Rationale**: Different hashing domains allow verifiers to distinguish between decision types while maintaining cryptographic integrity of the actual output content.

## Certificate Examples

### Example 1: Approved Computation (Pass)

```json
{
  "checker_version": "1.0.0",
  "input_sha256": "d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2",
  "output_sha256": "a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1",
  "decision": "pass",
  "violations": []
}
```

### Example 2: Blocked Computation with Violations

```json
{
  "checker_version": "1.0.0", 
  "input_sha256": "b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3",
  "output_sha256": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
  "decision": "blocked",
  "violations": [[23, 30], [58, 67]]
}
```

### Example 3: Rewritten Computation

```json
{
  "checker_version": "1.2.1",
  "input_sha256": "c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4", 
  "output_sha256": "f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5",
  "decision": "rewritten",
  "violations": [[12, 19]]
}
```

## Verification Procedure

### Step 1: Structural Validation

```python
def validate_certificate_structure(cert: dict) -> bool:
    required_fields = ["checker_version", "input_sha256", "output_sha256", "decision", "violations"]
    
    # Check all required fields present
    if not all(field in cert for field in required_fields):
        return False
    
    # Validate field types
    if not isinstance(cert["checker_version"], str):
        return False
    if not isinstance(cert["input_sha256"], str):
        return False  
    if not isinstance(cert["output_sha256"], str):
        return False
    if cert["decision"] not in ["pass", "blocked", "rewritten"]:
        return False
    if not isinstance(cert["violations"], list):
        return False
    
    # Validate field formats
    if not re.match(r'^\d+\.\d+\.\d+$', cert["checker_version"]):
        return False
    if not re.match(r'^[a-f0-9]{64}$', cert["input_sha256"]):
        return False
    if not re.match(r'^[a-f0-9]{64}$', cert["output_sha256"]):
        return False
    
    # Validate violations format
    for violation in cert["violations"]:
        if not isinstance(violation, list) or len(violation) != 2:
            return False
        if not isinstance(violation[0], int) or not isinstance(violation[1], int):
            return False
        if violation[0] >= violation[1] or violation[0] < 0:
            return False
    
    return True
```

### Step 2: Semantic Validation

```python
def validate_certificate_semantics(cert: dict) -> bool:
    decision = cert["decision"]
    violations = cert["violations"]
    output_hash = cert["output_sha256"]
    
    # Pass decisions must have no violations
    if decision == "pass" and len(violations) > 0:
        return False
    
    # Blocked/rewritten decisions must have violations
    if decision in ["blocked", "rewritten"] and len(violations) == 0:
        return False
    
    # Blocked decisions must hash empty string
    empty_hash = "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"
    if decision == "blocked" and output_hash != empty_hash:
        return False
    
    return True
```

### Step 3: Cryptographic Verification

```python
def verify_certificate_integrity(cert: dict, original_input: str, 
                                computation_output: str) -> bool:
    # Recompute input hash with same normalization pipeline
    computed_input_hash = compute_input_hash(original_input)
    if computed_input_hash != cert["input_sha256"]:
        return False
    
    # Verify output hash based on decision type
    if cert["decision"] == "pass":
        computed_output_hash = hashlib.sha256(computation_output.encode('utf-8')).hexdigest().lower()
    elif cert["decision"] == "blocked":
        computed_output_hash = "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"
    elif cert["decision"] == "rewritten":
        computed_output_hash = hashlib.sha256(computation_output.encode('utf-8')).hexdigest().lower()
    
    if computed_output_hash != cert["output_sha256"]:
        return False
    
    return True
```

### Step 4: Complete Verification Workflow

```python
def verify_certificate(cert_json: str, original_input: str, 
                      computation_output: str) -> dict:
    try:
        cert = json.loads(cert_json)
    except json.JSONDecodeError:
        return {"valid": False, "error": "Invalid JSON"}
    
    # Step 1: Structural validation
    if not validate_certificate_structure(cert):
        return {"valid": False, "error": "Invalid certificate structure"}
    
    # Step 2: Semantic validation  
    if not validate_certificate_semantics(cert):
        return {"valid": False, "error": "Invalid certificate semantics"}
    
    # Step 3: Cryptographic verification
    if not verify_certificate_integrity(cert, original_input, computation_output):
        return {"valid": False, "error": "Certificate integrity check failed"}
    
    return {
        "valid": True,
        "checker_version": cert["checker_version"],
        "decision": cert["decision"],
        "violation_count": len(cert["violations"])
    }
```

## Security Considerations

### Hash Collision Resistance
- SHA-256 provides 2^256 collision resistance
- Hash truncation not permitted - full 256 bits required
- Input normalization ensures consistent hashing despite Unicode variations

### Certificate Integrity
- Certificates are self-verifying through hash validation
- No external signatures required for basic integrity checking
- Tampered certificates will fail hash verification

### Replay Attack Prevention  
- Certificates bound to specific input/output pairs through hashes
- Reuse of certificates for different computations will fail verification
- No timestamp expiration - certificates remain valid indefinitely for same inputs

### Privacy Preservation
- Raw input content not included in certificates
- Only cryptographic hashes exposed
- Violation positions revealed but not violation content
- Output hashing domain varies to prevent information leakage

## Implementation Requirements

### Deterministic Behavior
- Same input must always produce identical certificates
- Normalization pipeline must be deterministic across platforms
- Hash computation must use consistent encoding (UTF-8)

### Performance Requirements  
- Certificate generation: <10ms per certificate
- Certificate verification: <5ms per certificate
- Memory usage: <1MB per certificate operation

### Compatibility
- JSON format ensures cross-platform compatibility
- UTF-8 encoding for all text content
- Standard SHA-256 implementation required

## Error Codes

| Code | Description | Action |
|------|-------------|---------|
| CERT_001 | Invalid JSON format | Reject certificate |
| CERT_002 | Missing required field | Reject certificate |
| CERT_003 | Invalid field format | Reject certificate |
| CERT_004 | Invalid decision value | Reject certificate |
| CERT_005 | Semantic inconsistency | Reject certificate |
| CERT_006 | Hash verification failed | Reject certificate |
| CERT_007 | Violation format invalid | Reject certificate |

## Revision History

| Version | Date | Changes |
|---------|------|---------|
| 1.0.0 | January 2025 | Initial specification |

---

**Classification**: Technical Specification  
**Approval**: Final  
**Next Review**: June 2025